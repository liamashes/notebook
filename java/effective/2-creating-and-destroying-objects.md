# 主题
> * 创建
> * 避免创建
> * 适时地销毁
> * 如何做销毁前的清理

## 条目1 静态工厂方法代替构造器
优势
> * 有名称（构造方法没有）
> * 单例：不必在每次调用它们的时候都创建一个新的对象（类似于享元模式），枚举保证了这一点
> * 可以返回原返回类型的任何子类型的对象
>   * 适用于基于接口的框架
>   * java8以后接口可以有静态方法
>   * java9允许接口有私有的静态方法，但静态域和静态成员类仍然需要时公有的
> * 所返回的对象的类可以随着每次调用而发生变化
>   * EnumSet
>       * 当元素有64个或更少，就返回RegularEnumSet实例，使用long进行支持；
>       * 如果有65个或更多，使用JumboEnumSet，使用long类型支持
>   * 实现的方式可以随着发行版本的不同而不同
> * 返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在
>   * 服务提供者框架的基础，如JDBC
>       * 三个重要组件：
>           * 服务接口（提供者实现）
>           * 提供者注册API（提供者用来注册实现）
>           * 服务访问API（客户端获取服务的实例）
>       * 第四个组件：服务提供者接口（产生服务接口之实例的工厂对象，没有就通过反射的方式进行实例化）
>       * 示例：
>           * Connection是服务接口的一部分
>           * DriverManager.registerDriver是提供者注册API
>           * DriverManager.getConnection是服务访问API
>           * Driver是服务提供者接口
>   * 服务提供者框架模式的变体
>       * 桥接模式：服务访问API返回比提供者需要的更丰富的服务接口
>       * 依赖注入框架
>   * java.util.ServiceLoader：Java平台提供的通用的服务提供者框架

缺点
> * 类如果不含公有的或者受保护的构造器，就不能被子类化
> * 程序员很难发现它们
>   * 常用的名称：from（转换）、of（聚合）、valueOf（）、instance或getInstance、create或newInstance、get**Type**、new**Type**、**Type**

## 条目2 遇到多个构造器参数时，要考虑


## 条目7 消除过期的对象引用
java.lang.ref.Reference

## 条目8 避免使用终结方法和清除方法
java.lang.ref.Cleaner  
java.lang.ref.Finalizer  


