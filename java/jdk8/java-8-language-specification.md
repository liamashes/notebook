# 封面
# 版权
# 前言
# 目录
# 第1章  概述
> * 一种通用的、支持并发的、基于类的面向对象的编程语言
>   * 与C和C++有很多联系，但是构成不同
>   * 用于生产，而非研究的语言
>   * 所有特性均测试
> * 一种强静态类型语言
>   * 区分了 **编译时** 和 **运行时** 错误
>   * 编译：程序 -> 字节码
>   * 运行：对类的加载和链接、（非必要）机器码生成和动态优化、程序运行
> * 一种相对高级的语言
>   * 屏蔽机器表现形式
>   * 垃圾回收器的自动内存管理，避免显式内存释放
>   * 避免不安全结构
## 1.1  本书结构
> * 第2章
>   * java语言的文法
>   * 用来表示词法和句法的表示法
> * 第3章
>   * java语言的词法结构：
>       * 基于C和C++
>       * Unicode字符集
>       * 只支持ASCII的系统上使用Unicode编写的程序
> * 第4章
>   * 阐述类型、值、变量；类型 -> 简单类型｜引用类型
>       * 简单类型：互相之间不共享状态
>           * 整数（以2的补码形式表示）
>           * 布尔
>           * 浮点数（单精度｜双精度；符合IEEE754标准）
>           * 字符（表示单个Unicode）
>       * 引用类型：类｜接口｜数组；声明可以泛化，使用时参数化
>       * 变量：类型化 的 存储位置
> * 第5章
>   * 类型转换｜数字提升
>       * 类型转换：改变编译时类型，有时会改变表达式的值；包括简单与引用之间的拆箱和装箱
>       * 数字提升：将数字型操作数 -> 公共类型，确保类型安全
> * 第6章
>   * 声明｜名字
>       * 名字：
>           * 如何确定名字的含义
>           * 对名字作用域的控制
>           * 从外部对 包｜类｜接口的成员 的访问进行限制（将 类型的实现 与 它的用户 分离），便于编写大型程序
>           * 介绍命名的习惯
>       * 声明：
>           * 不要求声明在使用之前
>           * 声明的顺序只对 局部变量｜局部类｜类或接口内的域初始化器 的顺序有影响
> * 第7章
>   * 程序的结构
>       * 包的成员：类｜接口｜子包
>       * 包划分成编译单元（包含类型声明，可以从其他包导入类型以便使用短名字引用它们）
>       * 包的名字位于层次化名字空间（使用互联网域名）
> * 第8章
>   * 类
>       * 成员：类｜接口｜域（变量）或方法
>       * 类-变量：整个类中只有一个实例的变量
>       * 类-方法：不需要指向具体对象的引用就可以运行的方法
>       * 单一继承：
>           * 类的实现是从单一超类派生，溯源均是Object；
>           * 类型变量可以引用该类及任意子类的实例，允许新类型可以多态地适用于现有的方法
>       * 其他
>           * 支持并发编程（synchronized）
>           * 方法可以声明：执行时受检类型，编译时可以检查
>           * 对象可以声明finalize方法，在被垃圾回收器丢弃之前被调用
>           * 无声明头文件，也没有分离的类型和类层次结构
>           * 枚举（特殊）：以类型安全的方式定义一个小的取值集；是对象，可以有方法（与其他语言不同）
> * 第9章
>   * 接口类型：一组 抽象方法｜成员类型｜常量类型
>       * 多个类可以实现相同的接口
>       * 接口类型的变量，可以指向实现该接口的任何对象的引用
>       * 支持多重接口继承
>       * 注解：特殊化接口，注解各类声明
> * 第10章
>   * 数组
>       * 访问：包含越界检查
>       * 数组是动态创建的，可以赋值给Object类型的对象。
>       * 支持元素为数组的数组，而不是多维数组
> * 第11章
>   * 异常
>       * 会改变程序执行的流程，与java语义和并发机制做了彻底的集成
>       * 种类：受检异常｜运行时异常｜错误
>       * 编译时检查：方法｜构造器 在声明它时，才可能抛出异常
>       * 用户定义：都是受检异常
> * 第12章
>   * 程序执行中发生的活动
>       * 程序 -> 二进制文件 -> 加载到jvm -> 与其他类和接口链接、初始化 -> 使用
>       * 对象是某个类的实例 -> 对象包含该类的每一个超类的引用（对这些超类实例的递归创建）
>       * 对象不再被引用 -> 垃圾回收器回收；不需要类 -> 卸载
> * 第13章
>   * 二进制可兼容性：修改类型 对 其他类型（使用修改后类型，但未重新编译） 的影响
> * 第14章
>   * 语句块和语句：源于C和C++
>       * 不包含goto，但是包含 break 和 continue
>       * 控制流语句必须是boolean和Boolean，不会将其他类型隐式转换为boolean（除拆箱外）
>       * synchronized提供 基本 对象级别 的 监视加锁 机制
>       * try｜catch｜finally：将控制流限定在局部
> * 第15章
>   * 表达式：赋值顺序 -> 提高 确定性｜可移植性
>       * 重载的方法｜构造器：在编译时解析（需要挑选）
> * 第16章
>   * 确保 局部变量 在使用前 一定先被 设置过
>       * 其他所有变量 都会有 缺省值，但 局部变量 没有 -> 避免掩盖编程错误
> * 第17章
>   * 线程和锁：以 随 Mesa编程语言 引入的 基于监视器的 并发机制 为基础
>       * 内存模型：针对支持 高性能实现的 具有 共享内存结构 的 多处理器
> * 第18章
>   * 测试泛型方法的可用性
>   * 在 泛型方法调用中 推断类型 的 类型推断算法
> * 第19章
>   * java语言的文法

## 1.2  样例程序
## 1.3  表示法
> * 除特别说明，N 引用的类｜接口，都是 java.lang包中 名为 N 的类｜接口
> * [F1:=T1,...,Fn:=Tn]，对于所有i，1 =< i =< n，Fi 被 Ti 替换
## 1.4  与预定义的类和接口的关系
> * Thread｜reflect 中，未做机制的完整说明
## 1.5  反馈
## 1.6  参考文献
# 第2章  文法
> * 程序词法
> * 句法结构的上下文无关文法
## 2.1  上下文无关文法
> * 由 **产生式** 构成
>   * **产生式**：左侧是**非终结符**的抽象符号，右侧是符号序列，由 1/多 个 非终结符 和 终结符 构成
>   * 
## 2.2  词法
## 2.3  句法
## 2.4  文法表示法
# 第3章  词法结构
## 3.1  Unicode
## 3.2  词法翻译
## 3.3  Unicode转义字符
> * \u 及跟着的 4位十六进制数
## 3.4  行终止符
> * CR LF CRLF
> * 两个会被当作一个
## 3.5  输入元素和符号
> *  不是 空白字符 和 注释 的输入元素被称为 符号，是句法的终结符
## 3.6  空白字符
> * 空格｜水平制表符｜换页符｜ 行终止符
## 3.7  注释
> * /* text */
> * //
> * 约定：注释不能出现在 字符字面常量 和 字符串字面常量 中
## 3.8  标识符
> * 定义：没有长度限制的 由Java字母和数字构成的 序列，首字符必须是Java字母
> * Java字母：A-Z（\u0041 - \u005a），a-z（\u0061 - \u007a），_（\u005f），$（\u0024）
> * Java数字：0-9（\u0030 - \u0039）
## 3.9  关键字
> * 50个
## 3.10  字面常量
> * 简单类型 String类型 空类型
### 3.10.1  整数字面常量
> * 数字后带有L或l，则类型位long，否则为int
> * 下划线可以作为表示整数的各个数字位之间的分隔符
> * 十六进制：前导字符 0x｜0X
> * 八进制：数字位0，后多出一个字符0-7
> * 二进制：前导字符 0b｜0B
### 3.10.2  浮点数字面常量
> * 包括：整数部分、十进制/十六进制 小数点、小数部分、指数、类型后缀
> * 如果表示指数，十进制：用e或E加上可选的有符号整数 十六进制：用p或P加上可选的有符号整数
> * 带有后缀F或f，即为float，否则为double(或带有d或D)
> * float示例：1e1f 2.f .3f 0f 3.14f 6.0221373e+23f
> * double示例：1e1 2.  .3  0.0 3.14 1e-9d 1e137
### 3.10.3  布尔字面常量
> * true false
### 3.10.4  字符字面常量
> * ''，中间是 单个字母（\u0000 - \uffff）｜带有转义符的字符
### 3.10.5  字符串字面常量
> * ""
### 3.10.6  字符和字符串字面常量的转义序列
> * \b：BS退格 \t：水平制表符HT \n：换行LF \f：换页FF \r：回车CR \" \' \\
### 3.10.7  空字面常量
> * null
## 3.11  分隔符
> * () {} [] ; , . ... @ ::
## 3.12  操作符
# 第4章  类型、值和变量
> * 静态类型：变量｜表达式 在编译时 有明确的 类型
> * 强类型：限制 变量可以持有的值 和 表达式可以产生的值 -> 编译时探测错误

## 4.1  类型和值的种类
> * 简单类型：
>   * 数值：整数（byte 8｜short 16｜int 32｜long 64｜char 16）｜浮点型（float 32位IEEE 754｜double 64位IEEE 754）
>   * 布尔：boolean
> * 引用类型：类类型｜接口类型｜数组类型｜空类型（特殊），对 对象 的 引用
> * 对象：动态创建的 类类型的实例 或 动态创建的数组
## 4.2  简单类型和值
> * 类型：简单类型｜引用类型｜空类型（null）
> * 值  ：简单值｜引用值
> * 空引用
>   * 只能是 空类型 表达式 的值
>   * 可以 被赋值给 或 被类型转换为 任何引用类型
### 4.2.1  整数类型和值
> * byte：-128 127
> * short：-32768 32767
> * int： -2147483648 2147483647
> * long：-9223372036854775808 922337203685477580
> * char：\u0000 \uffff | 0 65535
### 4.2.2  整数操作
> * 类型
>   * 比较操作符
>   * 数字操作符
>   * 条件操作符？
>   * 类型转换操作符
>   * 字符串连接操作符+
> * long：若至少有一个是long类型的 -> 那么会按照64位精度执行（另外一个进行数字提升） -> 结果也是long类型
> * int：上述为否的时候 -> 按照32位执行（另外一个进行数字提升） -> 结果是int类型
> * 转换：整数之间可以任意转换，但是无法与boolean转换
> * 溢出：不会提示 **上溢** 或 **下溢**；
> * 异常：
>   * 空引用拆箱
>   * 右操作数为0，操作符为 / %
>   * 装箱时，内存不足，那么 ++ -- 会抛出内存溢出的错误
### 4.2.3  浮点数类型、格式和值
> * 运算标准：ANSI/IEEE 754标准754-1985，该标准包含 +0｜-0｜正负无穷｜NaN（0/0）
> * 全局标准：java的每个实现 都需要支持 浮点值的两个标准集：单精度浮点值集｜双精度浮点值集
> * 通用表示：任何浮点值集中 有限非0值 均可以表示为s.m.2^(e-N+1)
>   * s： +1 或 -1
>   * m： 小于 2^N 的正整数
>   * e： Emin = -（2^K-1 - 2) 到 Emax = 2^K-1 - 1
>   * N、K：依赖所用值集的参数
>   * 其他：假设 v 可以用 s、m、e的 恰当取值 来表示
>       * 当m是偶数，e < 2^K-1  ->  将m取值减半，给e增加1  ->  可以产生v的第二种表示
>       * 如果m >= 2K-1，则称为**规格化表示**，否则就为**非规格化表示**
>       * 如果所有表示中，存在某个值为**非规格化表示**，则称之为**非规格化值**
### 4.2.4  浮点数操作
### 4.2.5  boolean类型和布尔值
## 4.3  引用类型和值
> * 类类型｜接口类型｜类型变量｜数组类型
### 4.3.1  对象
> * 类的实例｜数组
### 4.3.2  Object类
> * 所有其他类的超类
> * 方法：
>   * clone
>   * equals
>   * finalize
>   * getClass
>   * hashCode
>   * wait、notify、notifyAl
>   * toString
### 4.3.3  String类
> * String类的实例：Unicode码位序列
> * 对象都有不可修改的常量值
> * 字符串字面常量：对String类的实例的引用
> * 字符串连接符：可能会隐式创建新的String对象
### 4.3.4  当引用类型相同时
## 4.4  类型变量
> * 定义：类、接口、方法、构造器中 用作类型的 非限定标识符
> * 如果I1、I2均是I的扩展，那么C不能同时是I1、I2的子类型
## 4.5  参数化类型
> * 形式为C<T1,T2,...,Tn>的类或接口，C是泛型名，<T1,T2,...,Tn> 表示 该泛型的 特定参数化形式的 类型引元列表
### 4.5.1  参数化类型的类型引元
> * 类型引元：引用类型｜通配符
> * 边界：？ extends B
> * 下界：？ super B
### 4.5.2  参数化类型的成员和构造器
## 4.6  类型擦除
## 4.7  可具化类型
## 4.8  原生类型
## 4.9  交集类型
## 4.10  子类型化
### 4.10.1  简单类型之间的子类型化
### 4.10.2  类与接口类型之间的子类型化
### 4.10.3  数组类型之间的子类型化
### 4.10.4  最低上边界
## 4.11  使用类型之处
## 4.12  变量
### 4.12.1  简单类型的变量
### 4.12.2  引用类型的变量
### 4.12.3  变量的种类
### 4.12.4  final变量
### 4.12.5  变量的初始值
### 4.12.6  类型、类和接口
# 第5章  类型转换与上下文
## 5.1  转换的种类
### 5.1.1  标识转换
### 5.1.2  拓宽简单类型转换
### 5.1.3  窄化简单类型转换
### 5.1.4  拓宽和窄化简单类型转换
### 5.1.5  拓宽引用类型转换
### 5.1.6  窄化引用类型转换
### 5.1.7  装箱转换
### 5.1.8  拆箱转换
### 5.1.9  非受检转换
### 5.1.10  捕获转换
### 5.1.11  字符串转换
### 5.1.12  被禁止的转换
### 5.1.13  值集转换
## 5.2  赋值上下文
## 5.3  方法调用上下文
## 5.4  字符串上下文
## 5.5  强制类型转换上下文
### 5.5.1  引用类型强制类型转换
### 5.5.2  受检强制类型转换和非受检强制类型转换
### 5.5.3  运行时的受检强制类型转换
## 5.6  数字上下文
### 5.6.1  一元数字提升
### 5.6.2  二元数字提升
# 第6章  名字
## 6.1  声明
## 6.2  名字与标识符
## 6.3  声明的作用域
## 6.4  遮蔽和遮掩
### 6.4.1  遮蔽
### 6.4.2  遮掩
## 6.5  确定名字的含义
### 6.5.1  根据上下文的名字的句法分类
### 6.5.2  对上下文歧义名字的重分类
### 6.5.3  包名的含义
### 6.5.4  PackageOrTypeNames的含义
### 6.5.5  类型名的含义
### 6.5.6  表达式名的含义
### 6.5.7  方法名的含义
## 6.6  访问控制
### 6.6.1  确定可访问性
### 6.6.2  受保护访问权限的细节
## 6.7  完全限定名和规范名
# 第7章  包
## 7.1  包成员
## 7.2  主机对包的支持
## 7.3  编译单元
## 7.4  包声明
### 7.4.1  具名包
### 7.4.2  不具名包
### 7.4.3  包的可观察性
## 7.5  导入声明
### 7.5.1  单类型导入声明
### 7.5.2  按需类型导入声明
### 7.5.3  单静态导入声明
### 7.5.4  按需静态导入声明
## 7.6  顶层类型声明
# 第8章  类
## 8.1  类声明
### 8.1.1  类修饰符
### 8.1.2  泛化类和类型参数
### 8.1.3  内部类和包围实例
### 8.1.4  超类和子类
### 8.1.5  超接口
### 8.1.6  类体和成员声明
## 8.2  类成员
## 8.3  域声明
### 8.3.1  域修饰符
### 8.3.2  域的初始化
### 8.3.3  在域初始化过程中的向前引用
## 8.4  方法声明
### 8.4.1  形参
### 8.4.2  方法签名
### 8.4.3  方法修饰符
### 8.4.4  泛化方法
### 8.4.5  方法的结果
### 8.4.6  方法抛出异常
### 8.4.7  方法体
### 8.4.8  继承、覆盖和隐藏
### 8.4.9  重载
## 8.5  成员类型声明
### 8.5.1  静态成员类型声明
## 8.6  实例初始化器
## 8.7  静态初始化器
## 8.8  构造器声明
### 8.8.1  形参
### 8.8.2  构造器签名
### 8.8.3  构造器修饰符
### 8.8.4  泛化构造器
### 8.8.5  构造器抛出异常
### 8.8.6  构造器的类型
### 8.8.7  构造器体
### 8.8.8  构造器重载
### 8.8.9  缺省构造器
### 8.8.10  阻止类的实例化
## 8.9  枚举类型
### 8.9.1  枚举常量
### 8.9.2  枚举体声明
### 8.9.3  枚举成员
# 第9章  接口
## 9.1  接口声明
### 9.1.1  接口修饰符
### 9.1.2  泛化接口和类型参数
### 9.1.3  超接口和子接口
### 9.1.4  接口体和成员声明
## 9.2  接口成员
## 9.3  域(常量)声明
### 9.3.1  接口中域的初始化
## 9.4  方法声明
### 9.4.1  继承和覆盖
### 9.4.2  重载
### 9.4.3  接口方法体
## 9.5  成员类型声明
## 9.6  注解类型
### 9.6.1  注解类型元素
### 9.6.2  注解类型元素的缺省值
### 9.6.3  可重复的注解类型
### 9.6.4  预定义的注解类型
## 9.7  注解
### 9.7.1  普通注解
### 9.7.2  标记注解
### 9.7.3  单元素注解
### 9.7.4  注解可以出现在何处
### 9.7.5  同种类型的多重注解
## 9.8  函数型接口
## 9.9  函数类型
# 第10章  数组
## 10.1  数组类型
## 10.2  数组变量
## 10.3  数组创建
## 10.4  数组访问
## 10.5  数组存储异常
## 10.6  数组初始化器
## 10.7  数组成员
## 10.8  数组的Class对象
## 10.9  字符数组不是String
# 第11章  异常
## 11.1  异常的种类和成因
### 11.1.1  异常的种类
### 11.1.2  异常的成因
### 11.1.3  异步异常
## 11.2  异常的编译时检查
### 11.2.1  表达式异常分析
### 11.2.2  语句异常分析
### 11.2.3  异常检查
## 11.3  异常的运行时处理
# 第12章  执行
## 12.1  Java虚拟机启动
### 12.1.1  加载Test类
### 12.1.2  链接Test：校验、准备、(可选的)解析
### 12.1.3  初始化Test：执行初始化器
#### 12.1.4  调用Test.main
## 12.2  加载类和接口
### 12.2.1  加载过程
## 12.3  链接类和接口
### 12.3.1  二进制表示的校验
### 12.3.2  类或接口类型的准备
### 12.3.3  符号引用的解析
## 12.4  初始化类和接口
### 12.4.1  当初始化发生时
### 12.4.2  详细的初始化过程
## 12.5  创建新的类实例
## 12.6  类实例的终结
### 12.6.1  实现终结
### 12.6.2  与内存模型的交互
## 12.7  卸载类和接口
## 12.8  程序退出
# 第13章  二进制兼容性
## 13.1  二进制形式
## 13.2  二进制兼容性到底是什么
## 13.3  包的演化
## 13.4  类的演化
### 13.4.1  abstract类
### 13.4.2  final类
### 13.4.3  public类
### 13.4.4  超类和超接口
### 13.4.5  类的类型参数
### 13.4.6  类体和成员声明
### 13.4.7  对成员和构造器的访问权限
### 13.4.8  域声明
### 13.4.9  final域和static常量变量
### 13.4.10  static域
### 13.4.11  transient域
### 13.4.12  方法和构造器声明
### 13.4.13  方法和构造器的类型参数
### 13.4.14  方法和构造器的形式参数
### 13.4.15  方法返回类型
### 13.4.16  abstract方法
### 13.4.17  final方法
### 13.4.18  native方法
### 13.4.19  static方法
### 13.4.20  synchronized方法
### 13.4.21  方法和构造器的抛出物
### 13.4.22  方法和构造器体
### 13.4.23  方法和构造器的重载
### 13.4.24  方法覆盖
### 13.4.25  静态初始化器
### 13.4.26  枚举的演化
## 13.5  接口的演化
### 13.5.1  public接口
### 13.5.2  超接口
### 13.5.3  接口成员
### 13.5.4  接口的类型参数
### 13.5.5  域声明
### 13.5.6  接口方法声明
### 13.5.7  注解类型的演化
# 第14章  块和语句
## 14.1  语句的正常结束和猝然结束
## 14.2  块
## 14.3  局部类声明
## 14.4  局部变量声明语句
### 14.4.1  局部变量声明符和类型
### 14.4.2  局部变量声明的执行
## 14.5  语句
## 14.6  空语句
## 14.7  标号语句
## 14.8  表达式语句
## 14.9  if语句
### 14.9.1  if-then语句
### 14.9.2  if-then-else语句
## 14.10  assert语句
## 14.11  switch语句
## 14.12  while语句
### 14.12.1  while语句的猝然结束
## 14.13  do语句
### 14.13.1  do语句的猝然结束
## 14.14  for语句
### 14.14.1  基本for语句
### 14.14.2  增强for语句
## 14.15  break语句
## 14.16  continue语句
## 14.17  return语句
## 14.18  throw语句
## 14.19  synchronized语句
## 14.20  try语句
### 14.20.1  try-catch的执行
### 14.20.2  try-finally和try-catch-finally的执行
### 14.20.3  带资源的try
## 14.21  不可达语句
# 第15章  表达式
## 15.1  计算、表示和结果
## 15.2  表达式的形式
## 15.3  表达式的类型
## 15.4  FP-严格的表达式
## 15.5  表达式和运行时检查
## 15.6  计算的正常和猝然结束
## 15.7  计算顺序
### 15.7.1  首先计算左操作数
### 15.7.2  在操作之前计算操作数
### 15.7.3  计算遵循括号和优先级
### 15.7.4  引元列表是自左向右计算的
### 15.7.5  其他表达式的计算顺序
## 15.8  基本表达式
### 15.8.1  词法上的字面常量
### 15.8.2  类字面常量
### 15.8.3  this
### 15.8.4  限定的this
### 15.8.5  带括号的表达式
## 15.9  类实例创建表达式
### 15.9.1  确定要实例化的类
### 15.9.2  确定包围实例
### 15.9.3  选择构造器及其引元
### 15.9.4  类实例创建表达式的运行时计算
### 15.9.5  匿名类声明
## 15.10  数组创建和访问表达式
### 15.10.1  数组创建表达式
### 15.10.2  数组创建表达式的运行时执行
### 15.10.3  数组访问表达式
### 15.10.4  数组访问表达式的运行时计算
## 15.11  域访问表达式
### 15.11.1  使用基本表达式访问域
### 15.11.2  使用super访问超类成员
## 15.12  方法调用表达式
### 15.12.1  编译时的步骤1：确定要搜索的类或接口
### 15.12.2  编译时的步骤2：确定方法签名
### 15.12.3  编译时的步骤3：选中的方法是否合适
### 15.12.4  方法调用的运行时计算
## 15.13  方法引用表达式
### 15.13.1  方法引用的编译时声明
### 15.13.2  方法引用的类型
### 15.13.3  方法引用的运行时计算
## 15.14  后缀表达式
### 15.14.1  表达式名字
### 15.14.2  后缀递增操作符++
### 15.14.3  后缀递减操作符--
## 15.15  一元操作符
### 15.15.1  前缀递增操作符++
### 15.15.2  前缀递减操作符--
### 15.15.3  一元加号操作符+
### 15.15.4  一元减号操作符-
### 15.15.5  按位取反操作符~
### 15.15.6  逻辑取反操作符!
## 15.16  强制类型转换表达式
## 15.17  乘除操作符
### 15.17.1  乘法操作符*
### 15.17.2  除法操作符/
### 15.17.3  取余操作符%
## 15.18  加减操作符
### 15.18.1  字符串连接操作符+
### 15.18.2  用于数字类型的加减操作符 (+和-)
## 15.19  移位操作符
## 15.20  关系操作符
### 15.20.1  数字比较操作符<、<=、>和>=
### 15.20.2  类型比较操作符instanceof
## 15.21  判等操作符
### 15.21.1  数字判等操作符==和!=
### 15.21.2  布尔判等操作符==和!=
### 15.21.3  引用判等操作符==和!=
## 15.22  位操作符与逻辑操作符
### 15.22.1  整数位操作符&、^和｜
### 15.22.2  布尔逻辑操作符&、^和｜
## 15.23  条件与操作符&&
## 15.24  条件或操作符||
## 15.25  条件操作符?:
### 15.25.1  布尔条件表达式
### 15.25.2  数字型条件表达式
### 15.25.3  引用条件表达式
## 15.26  赋值操作符
### 15.26.1  简单赋值操作符=
### 15.26.2  复合赋值操作符
## 15.27  lambda表达式
> * 像一个方法，提供了形式参数列表 以及 根据这些参数表示的体： 参数 -> 体
> * 是合成表达式，上下文限制：赋值｜调用｜强制类型转换
> * 优点：最小化括号对简单lambda表达式带来的噪声
> * 限制：
>   * 不能声明类型参数
>   * 不存在任何特殊的空元形式
### 15.27.1  lambda参数
> * 形式参数：可以声明的类型｜推断的类型，不可以混用
### 15.27.2  lambda体
> * 表达式，块
> * 在lambda体中的关键字this、super的含义，与被引用的声明的可访问性一起，和在其包围上下文中的含义相同
### 15.27.3  lambda表达式的类型
### 15.27.4  lambda表达式的运行时计算
## 15.28  常量表达式
# 第16章  明确赋值
## 16.1  明确赋值和表达式
### 16.1.1  布尔常量表达式
### 16.1.2  条件与操作符&&
### 16.1.3  条件或操作符||
### 16.1.4  逻辑取反操作符!
### 16.1.5  条件操作符?:
### 16.1.6  其他boolean类型的表达式
### 16.1.7  赋值表达式
### 16.1.8  操作符++和--
### 16.1.9  其他表达式
## 16.2  明确赋值与语句
### 16.2.1  空语句
### 16.2.2  块
### 16.2.3  局部类声明语句
### 16.2.4  局部变量声明语句
### 16.2.5  标号语句
### 16.2.6  表达式语句
### 16.2.7  if语句
### 16.2.8  assert语句
### 16.2.9  switch语句
### 16.2.10  while语句
### 16.2.11  do语句
### 16.2.12  for语句
### 16.2.13  break、continue、return和throw语句
### 16.2.14  synchronized语句
### 16.2.15  try语句
## 16.3  明确赋值与参数
## 16.4  明确赋值与数组初始化器
## 16.5  明确赋值与枚举常量
## 16.6  明确赋值与匿名类
## 16.7  明确赋值与成员类型
## 16.8  明确赋值与静态初始化器
## 16.9  明确赋值、构造器和实例初始化器
# 第17章  线程与锁
## 17.1  同步
## 17.2  等待集和通知
### 17.2.1  等待
### 17.2.2  通知
### 17.2.3  中断
### 17.2.4  等待、通知和中断的交互
## 17.3  睡眠和让步
## 17.4  内存模型
### 17.4.1  共享变量
### 17.4.2  动作
### 17.4.3  程序和程序顺序
### 17.4.4  同步顺序
### 17.4.5  “之前发生”顺序
### 17.4.6  执行
### 17.4.7  良构执行
### 17.4.8  执行和因果关系要求
### 17.4.9  可观察的行为和不终止的执行
## 17.5  final域的语义
### 17.5.1  final域的语义
### 17.5.2  在构造阶段读final域
### 17.5.3  对final域的后续修改
### 17.5.4  写受保护的域
## 17.6  字撕裂
## 17.7  double和long的非原子化处理
# 第18章  类型推断
## 18.1  概念与表示法
### 18.1.1  推断变量
### 18.1.2  约束公式
### 18.1.3  边界
## 18.2  归纳
### 18.2.1  表达式可兼容性约束
### 18.2.2  类型可兼容性约束
### 18.2.3  子类型化约束
### 18.2.4  类型相等性约束
### 18.2.5  受检异常约束
## 18.3  合并
### 18.3.1  互补的边界对
### 18.3.2  涉及捕获转换的边界
## 18.4  解析
## 18.5  推断的使用
### 18.5.1  调用可应用性的推断
### 18.5.2  调用类型的推断
### 18.5.3  函数型接口的参数化版本推断
### 18.5.4  更具体方法的推断
# 第19章  语法
# 索引
