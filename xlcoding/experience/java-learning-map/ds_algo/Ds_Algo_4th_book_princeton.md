1.3 
    1.3.2
        1.3.2.4
            对象游离
1.4 算法分析
    1.4.3
        数学模型
        近似运行时间
        算法分析
        成本模型
    1.4.4
        增长数量级的分类
1.5.2
    quick find -> quick union -> 加权quick union -> 工程级别的使用
    
# 封面
# 书名
# 目录
# 第1章 基础
    本章内容
> * 便于 算法操作 的 组织数据 的方法
> * RoadMap
>   * 基础编程模型
>   * 数据抽象
>   * 应用程序编程接口（API）-> 实现 抽象数据类型（ADT）
>   * 实例：背包｜队列｜栈 【起点｜样板】
>   * 性能：【循环式】*【提出假设 -> 建立数学模型 -> 实验验证】
>   * 示例：连通性 -> union-find抽象数据结构

    算法
> * 性质：与编程语言无关
> * 定位：一种 有限｜确定｜有效的 并 适合用计算机程序 来 实现的 解决问题的办法
> * 节约：有效利用 时间｜空间

    书的框架
> 章节 |  概述
> --- | ---
> [第1章 基础](#第1章-基础) | 用来 实现｜分析｜比较算法 的基本原则和方法：Java编程模型｜数据抽象｜基本数据结构｜集合类的抽象数据类型｜算法性能分析的方法｜一个案例分析
> [第2章 排序](#第2章-排序) | 研究：插入｜选择｜希尔｜快速｜归并｜堆 排序；讨论：和排序相关的问题（优先队列、选举、归并等）
> [第3章 查找](#第3章-查找) | 基本和高级的算法：二叉查找树｜平衡查找树｜散列表；分析：梳理关系｜比较性能
> [第4章 图](#第4章-图) | 对象与连接（权重｜方向）；内容：深度优先搜索｜广度优先搜索｜连通性问题｜若干其他算法（Kruskal和Prim的最小生成树｜Dijkstra和Bellman-Ford的最短路径算法）
> [第5章 字符串](#第5章-字符串) | 算法：对字符串键的排序和查找的快速算法｜子字符串查找｜正则表达式模式匹配｜数据压缩；相关领域的前沿话题
> [第6章 背景](#第6章-背景) | 前沿领域：科学计算｜运筹学｜计算理论。介绍：事件的模拟｜B树｜后缀数组｜最大流量问题｜其他；讲解：搜索问题｜问题转化｜NP完全性

## 1.1 基础编程模型
### 1.1.1 Java程序的基本结构
使用 大多数现代语言共有的：
> * 1、原始数据类型
> * 2、语句
> * 3、数组
> * 4、静态方法
> * 5、字符串
> * 6、标准输入/输出
> * 7、数据抽象
### 1.1.2 原始数据类型与表达式
> * 数据类型：整型｜浮点型｜布尔型｜字符型
> * 表达式：运算符；优先级
> * 类型转换：是否损失
> * 比较：表达式的一种
### 1.1.3 语句
> * 声明：关联 变量名 和 类型；强一致性检查
> * 赋值：关联 变量 和 值
> * 条件：改变执行流程
> * 循环：改变执行流程
> * 调用、返回：改变执行流程 和 代码组织
### 1.1.4 简便记法
清晰｜优雅｜高效
> * 声明并初始化
> * 隐式赋值：i++; i/=2
> * 单语句代码段
> * for语句
### 1.1.5 数组
索引 存储 访问
> *  创建、初始化 -> 使用
> * 二维数组：第一维是行数，第二位是列数
### 1.1.6 静态方法
静态方法：函数，使用static修饰
> * 性质：
>   * 方法的参数按值传递
>   * 方法名可以被重载
>   * 只能返回一个值
>   * 可以产生副作用：void无返回值
> * 递归：
>   * 总有一个最简单的情况
>   * 尝试解决一个 规模更小 的问题
>   * 父问题和子问题不能有交集
> * 模块化｜单元测试｜外部库
### 1.1.7 API
> * 定义：记录库方法的用法并供其他人参考的文档
> * 目的：调用、实现 分离
> * 标准库：
>   * 抽象层：有助于集中实现和测试
>   * 大量测试，覆盖极端和罕见，提高可信度
> * 自己编写：
>   * 编写用例：过程分解、可控
>   * 明确：方法库和API
>   * 测试：拥有独立测试的main函数
### 1.1.8 字符串
> * 拼接：+
> * 类型转换：
> * 自动转化：
> * 命令行参数
### 1.1.9 输入输出
> * 命令参数
> * 标准输出
> * 格式化输出
> * 标准输入
> * 重定向与管道
> * 基于文件的输入输出
> * 标准绘图库：StdDraw
### 1.1.10 二分查找
> * 著名、高效、应用广泛
> * 白名单过滤： java BinarySearch tinyW.txt < tinyT.txt
> * 性能：
### 1.1.11 展望
数据抽象
> * 通过模块化复用代码
> * 轻易构造多种链式数据结构
> * 准确定义面对的算法问题
### 1.1.12 答疑&练习
    答疑
> * 整型的溢出
> * 除数为0和0.0的区别
> * 负数的除法和余数
> * 短路法
> * if嵌套的二义性
> * for、while的区别：递增变量 在 循环结束后 是否可用
> * int a[] 和 int[] a
> * 可以重新读取输入中的值
> * java中，一个静态方法可以吧另一个静态方法作为参数吗

    练习
    
    提高
    
    实验
## 1.2 数据抽象
> * 原则上：所有程序只使用原始数据类型即可，抽象可以方便编写
> * 基础：面向对象
> * 使用：
>   * 以 适用于各种用途的API形式准确地定义问题
>   * 用API的实现描述算法和数据结构
### 1.2.1 使用抽象数据类型
使用不需要知道如何实现
> * 抽象数据类型的API
> * 继承的方法
> * 用例代码
> * 对象：
>   * 三大特性：状态｜标识｜行为
>   * 创建：
>       * 分配内存空间
>       * 构造函数，初始化对象中的值
>       * 返回对象的一个引用
>   * 调用实例方法
>   * 使用对象
>   * 赋值语句
>   * 对象作为参数
>   * 对象作为返回值
>   * 数组也是对象
>   * 对象的数组
### 1.2.2 抽象数据类型举例
将会用到或开发的类型：
> * java.lang.*
> * java标准库：java.swt java.net java.io
> * I/O处理类
> * 面向数据类
> * 集合类：Bag、Stack、Queue、SET
> * 面向操作类
> * 图算法相关

几何对象：
> * Point2D
> * Interval1D
> * Interval2D

信息处理

字符串

再谈输入输出

### 1.2.3 抽象数据类型的实现
### 1.2.4 更多抽象数据类型的实现
### 1.2.5 数据类型的设计
### 1.2.6 答疑&练习
## 1.3 背包、队列和栈
### 1.3.1 API
### 1.3.2 集合数据类型的实现
### 1.3.3 链表
### 1.3.4 综述
### 1.3.5 答疑&练习
## 1.4 算法分析
### 1.4.1 科学方法
### 1.4.2 观察
### 1.4.3 数学模型
### 1.4.4 增长数量级的分类
### 1.4.5 设计更快的算法
### 1.4.6 倍率实验
### 1.4.7 注意事项
### 1.4.8 处理对于输入的依赖
### 1.4.9 内存
### 1.4.10 展望
### 1.4.11 答疑&练习
## 1.5 案例研究：union-find算法
### 1.5.1 动态连通性
### 1.5.2 实现
### 1.5.3 展望
### 1.5.4 答疑&练习
# 第2章 排序
## 2.1 初级排序算法
### 2.1.1 游戏规则
### 2.1.2 选择排序
### 2.1.3 插入排序
### 2.1.4 排序算法可视化
### 2.1.5 比较两种排序算法
### 2.1.6 希尔排序
### 2.1.7 答疑&练习
## 2.2 归并排序
### 2.2.1 原地归并的抽象方法
### 2.2.2 自顶而下的归并排序
### 2.2.3 自底向上的归并排序
### 2.2.4 排序算法的复杂度
### 2.2.5 答疑&练习
## 2.3 快速排序
### 2.3.1 基本算法
### 2.3.2 性能特点
### 2.3.3 算法改进
### 2.3.4 答疑&练习
## 2.4 优先队列
### 2.4.1 API
### 2.4.2 初级实现
### 2.4.3 堆的定义
### 2.4.4 堆的算法
### 2.4.5 堆排序
### 2.4.6 答疑&练习
## 2.5 应用
### 2.5.1 将各种数据排序
### 2.5.2 我应该使用哪种排序算法
### 2.5.3 问题的归约
### 2.5.4 排序应用一览
### 2.5.5 答疑&练习
# 第3章 查找
## 3.1 符号表
### 3.1.1 API
### 3.1.2 有序符号表
### 3.1.3 用例举例
### 3.1.4 无序链表中的顺序查找
### 3.1.5 有序数组中的二分查找
### 3.1.6 对二分查找的分析
### 3.1.7 预览
### 3.1.8 答疑&练习
## 3.2 二叉查找树
### 3.2.1 基本实现
### 3.2.2 分析
### 3.2.3 有序性相关的方法与删除操作
### 3.2.4 答疑&练习
## 3.3 平衡查找树
### 3.3.1 2-3查找树
### 3.3.2 红黑二叉查找树
### 3.3.3 实现
### 3.3.4 删除操作
### 3.3.5 红黑树的性质
### 3.3.6 答疑&练习
## 3.4 散列表
### 3.4.1 散裂函数
### 3.4.2 基于拉链法的散列表
### 3.4.3 基于线性探测法的散列表
### 3.4.4 调整数组大小
### 3.4.5 内存使用
### 3.4.6 答疑&练习
## 3.5 应用
### 3.5.1 我应该使用符号表的哪种实现
### 3.5.2 集合的API
### 3.5.3 字典类用例
### 3.5.4 索引类用例
### 3.5.5 稀疏向量
### 3.5.6 答疑&练习
# 第4章 图
## 4.1 无向图
### 4.1.1 术语表
### 4.1.2 表示无向图的数据类型
### 4.1.3 深度优先搜索
### 4.1.4 寻找路径
### 4.1.5 广度优先搜索
### 4.1.6 连通分量
### 4.1.7 符号图
### 4.1.8 总结
### 4.1.9 答疑&练习
## 4.2 有向图
### 4.2.1 术语
### 4.2.2 有向图的数据类型
### 4.2.3 有向图的可达性
### 4.2.4 环和有向无环图
### 4.2.5 有向图中的强连通性
### 4.2.6 总结
### 4.2.7 答疑&练习
## 4.3 最小生成树
### 4.3.1 原理
### 4.3.2 加权无向图的数据类型
### 4.3.3 最小生成树的API和测试用例
### 4.3.4 Prim算法
### 4.3.5 Prim算法的即时实现
### 4.3.6 Kruskal算法
### 4.3.7 展望
### 4.3.8 答疑&练习
## 4.4 最短路径
### 4.4.1 最短路径的性质
### 4.4.2 加权有向图的数据结构
### 4.4.3 最短路径算法的理论基础
### 4.4.4 Dijkstra算法
### 4.4.5 无环加权有向图中的最短路径算法
### 4.4.6 一般加权有向图中的最短路径问题
### 4.4.7 展望
### 4.4.8 答疑&练习
# 第5章 字符串
### 5.0.1 游戏规则
### 5.0.2 字母表
## 5.1 字符串排序
### 5.1.1 键索引计数法
### 5.1.2 低位优先的字符串排序
### 5.1.3 高位优先的字符串排序
### 5.1.4 三向字符串快速排序
### 5.1.5 字符串排序算法的选择
### 5.1.6 答疑&练习
## 5.2 单词查找树
### 5.2.1 单词查找树
### 5.2.2 单词查找树的性质
### 5.2.3 三向单词查找树
### 5.2.4 三向单词查找树的性质
### 5.2.5 应该使用字符串符号表的哪种实现
### 5.2.6 答疑&练习
## 5.3 子字符串查找
### 5.3.1 历史简介
### 5.3.2 暴力子字符串查找算法
### 5.3.3 Knuth-Morris-Pratt子字符串查找算法
### 5.3.4 Boyer-Moore字符串查找算法
### 5.3.5 Rabin-Karp指纹字符串查找算法
### 5.3.6 总结
### 5.3.7 答疑&练习
## 5.4 正则表达式
### 5.4.1 使用正则表达式描述模式
### 5.4.2 缩略写法
### 5.4.3 正则表达式的实际应用
### 5.4.4 非确定有限状态自动机
### 5.4.5 模拟NFA的运行
### 5.4.6 构造与正则表达式对应的NFA
### 5.4.7 答疑&练习
## 5.5 数据压缩
### 5.5.1 游戏规则
### 5.5.2 读写二进制数据
### 5.5.3 局限
### 5.5.4 基因组
### 5.5.5 游戏编码
### 5.5.6 霍夫曼压缩
### 5.4.7 答疑&练习
# 第6章 背景
### 6.0.1 事件驱动模拟
### 6.0.2 B-树
### 6.0.3 后缀数组
### 6.0.4 网络流算法
### 6.0.5 问题规约
### 6.0.6 不可解性
### 6.0.7 练习
# 索引

