* 源码获取及IDE搭建
* JDBC规范
* 常用工具类
* 核心组件介绍
* SqlSession的创建
* SqlSession执行Mapper
* 缓存
* 日志
* 动态SQL原理
* 插件原理
* 级联映射与懒加载
* 与spring整合
* Mybatis Spring的实现原理

# 源码获取及搭建环境
1. Clinton Begin开发的Ibatis并捐献给Apache（2002）-> Apache迁移至Google Code，改名Mybatis
2. 说明：SQL映射框架；半自动ORM框架；SQL编写与运行分离
3. 主流：自动处理参数和结果；灵活、简单；与Spring集成；提供缓存机制（与第三方缓存类库集成）
4. 地址：https://github.com/mybatis/mybatis-3
5. 单元测试库：HSQLDB：同时支持内存、磁盘存储的数据库引擎，支持Server模式、内存模式；相关示例
# JDBC规范
1. 基于X/Open SQL CLI，是ODBC的基础
2. 过程：建立连接（4.0以前，需要显式加载驱动类） -> 执行SQL（execute、executeXXXX） -> 检索SQL执行结果（ResultSet） -> 关闭连接
3. 连接（Connection）：a. DriverManager(1.0)，加载CLASSPATH下所有的JDBC驱动来通过URL连接数据源 b. DataSource(2.0)，更多细节，但只提供接口，需要自己实现，可以通过工厂模式创建实例；   使用：通过相关方法可以创建Statement、PreparedStatement、CallableStatement
4. 扩展：ConnectionPoolDataSource：支持Connection的复用；XADataSource：Connection支持分布式事务
5. 特性：通过DatabaseMetaData支持不同的SQL规范、数据源是否支持某一特性
6. java.sql的API接口：Wrapper、Connection、Statement、CallableStatement、PreparedStatement、DatabaseMetaData、ParameterMetaData、ResultSet、ResultSetMetaData，所有接口均继承了Wrapper
7. Javax.sql接口：DataSource、CommonDataSource、ConnectionPoolDataSource、PooledConnection、ConnectionEvent、ConnectionEventListener、StatementEvent、StatementEventListener
8. javax.sql.RowSet：继承自java.sql.ResultSet，可滚动、可更新、可序列化的结果集，相当于表数据在应用程序内存中的映射；在生命周期中维持该连接，在内存中完成后批量提交到数据源
9. JDBC驱动类型：ODBC Bridge（多层调用转换会影响性能）、Native API（调用数据库原生链接库或客户端，无中间过程，不能跨平台）、JDBC-Net（独立于数据库的协议，通过中间件或服务器转换为数据库通信协议，不常见，微软的ADO.NET使用这种架构）、Native Protocol（通过数据库厂商直接提供驱动）
10. java.sql.Driver：实现类需要提供一个无参构造函数，向DriverManager中注册一个自己的实例；DriverManager通过实现类的acceptsURL()来判断一个给定的URL是否与数据库成功建立连接，调用connect(url,info)建立连接；
11. SPI机制：Service Provider Interface，动态替换的发现机制；在META-INF/services中创建一个以服务接口命名的文件（包含实现类）；使用java.util.ServiceLoader来查找；提供静态方法load加载指定接口的所有实现类
12. DriverManager加载过程：静态初始化：使用ServiceLoader机制加载Driver接口的所有实现类，遍历加载所有实现类，注册到DriverManager中；驱动加载时隐式调用registerDriver，getConnection获取数据库连接的Connection对象，可以在获取时提供额外的配置信息Info（java.util.Properties）
13. DriverAction：监听DriverManager中deregisterDriver（解除注册）方法的调用；不建议应用程序使用；通过registerDriver(driver, DriverAction)确保成功监听
14. DataSource：推荐使用，提供应用程序可移植性；使用JNDI（java naming and directory interface）映射逻辑名称和数据源对象；通过连接池提高系统性能和伸缩性；通过XADataSource支持分布式事务；实现类必须提高一个无参构造方法；标准属性：databaseName, dataSourceName, description, networkProtocol, password, portNumber, roleName, serverName, user；提供私有的get和set方法，通过内省机制访问；
15. JNDI增强应用的移植性：通过网络访问远程服务；通过命名服务绑定逻辑名称和具体对象；过程：创建Properties，设置属性 -> 根据Properties创建Context -> 绑定名称和现有的服务对象 -> 通过名称查找服务
16. 关闭服务：close()、isClosed、isValid；
17. Statement：定义执行SQL的方法（不支持参数输入），PreparedStatement（扩展Statement）增加了设置SQL参数的方法，CallableStatement（扩展PreparedStatement）接口增加了调用存储过程、检索存储过程调用结果的方法；来源：Connection.createStatement，创建时可以指定ResultSet的属性（可滚动的、可修改的、提交不会被关闭等）；与数据库交互：批量执行、执行未知语句、查询、更新、执行结果处理、大量（大于最大整形）数据更新、取消sql执行（需要数据库和驱动支持）；执行时可以指定三种参数：autoGeneratedKeys、columnIndexs、columnNames；getMoreResults获取下一个结果，返回true，则下一个结果为ResultSet，为false，说明下一个结果影响行数，或者没有更多结果，调用时默认关闭上一次调用生成的ResultSet对象，可以重载方法来指定是否关闭ResultSet（关闭当前、关闭所有未关闭、不关闭）；通过DatabaseMetaData提供的supportsMultipleOpenResults确认是否支持getMoreResults；批次相关方法：addBatch、clearBatch、executeBatch；通过函数可以设置相关参数
18. PreparedStatement：在Statement基础上增加了参数占位符（使用？）功能，实例表示可以被预编译的SQL语句，执行一次后后续执行时效率变高；创建时需要提供SQL语句（带有占位符）作为参数：Connection.prepareStatement(sql)，执行前需要设置相关参数，设置操作会将java类型数据转换为JDBC类型（java.sql.Types)，setNull用来指定jdbc的NULL；
19. CallableStatement：创建方式，Connection.prepareCall(“{? = call validate(?, ?)}”)，可以使用三种类型参数：IN、OUT、INOUT；除了使用序号指定值，也可以通过存储过程的参数名称指定参数，通过DatabaseMetaData提供的supportsNamedParameters来判断JDBC驱动是否支持指定命名参数
20. 获取自增主键值：执行时指定参数execute（sql，参数），参数可以是：生成的主键是否可以被检索；可以被检索的字段
21. ResultSet：检索和操作SQL执行结果，类型体现在：游标操作的方式、ResultSet的修改对于数据库的影响；TYPE_FORWARD_ONLY：游标只能向前移动；TYPE_SCROLL_INSENSITIVE：可以随意移动，且修改不影响数据库；TYPE_SCROLL_SENSITIVE：可以随意移动，修改数据会影响数据库；DatabaseMetaData中提供supportResultSetType来确定数据库是否支持某种类型的数据结果操作；产生的ResultSet对象可以通过getType判断它的类型；并行性：CONCUR_READ_ONLY表示只能读取不能更新，CONCUR_UPDATABLE表示可读可更新，DatabaseMetaData中提供supportResultSetConcurrency可以判断该属性的类型；可保持性：Connection.commit会关闭当前事务的ResultSet对象，创建Statement及同类接口时，可以指定参数：HOLD_CURSORS_OVER_COMMIT表示commit提交时不关闭ResultSet对象，CLOSE_CURSORS_AT_COMMIT表示会关闭（提升性能）；以上三个参数在创建S时均可以指定；游走函数：next、previous、first、last、beforeFirst、afterLast、relative（相对运行）、absolute（绝对运动）；修改：需要数据库支持；两个阶段：修改、同步，DatabaseMetaData的ownUpdatesAreVisible判断指定类型的ResultSet对象的更新是否对其他事务可见，通过updateXXX后，不应该调用updateRow或cancelRowUpdates修改之前通过updateXXX修改过的值；可以通过deleteRow来进行删除，DatabaseMetaData的ownDeletesAreVisible；插入操作：数据库要支持，操作：移动游标到对应位置、调用ResultSet的updateXXX方法设置字段值、插入行到当前ResultSet对象，DatabaseMetaData的ownInsertsAreVisible；关闭：显示：调用close、显示关闭Statement或Connection，隐式：相关联的Statement对象重复执行、CLOSE_CURSORS_AT_COMMIT + commit、（部分）TYPE_FORWARD_ONLY + next返回false
22. DatabaseMetaData：确定如何与底层数据源交互，方法涉及：数据源的信息、是否支持某功能、限制、包含的SQL对象及对象属性、对事务的支持；获取：connection.getMetaData；
23. 事务：符合SQL：2003规范，主要包含：自动提交、事务隔离级别、保存点；并发访问的问题：脏读（读取未提交的数据）、不可重复读（读、改、读）、幻读（条件读、插入同条件数据、再次条件读）；隔离级别：TRANSACTION_NONE（不支持事务）、TRANSACTION_READ_UNCOMMITED（读取未提交，以上问题均有）、TRANSACTION_READ_UNCOMMITED（未提交时不可见，会出现不可重复读、幻读）、TRANSACTION_REPEATABLE_READ（会出现幻读）、TRANSACTION_SERIALIZABLE（全部事务串行，效率低）；DatabaseMetaData中提供supportTransactionIsolationLevel；
24. 事务保存点：在事务中标记一个中间点，对事务进行更细粒度的控制，事务可以回滚到保存点；setSavepoint返回的Savepoint对象可以作为Rollback方法的参数；DatabaseMetaData中提供supportsSavepoints；
# Mybatis常用工具类
1. 通过SQL对象构建sql语句：new SQL() {{}}，可以动态拼接；SQL -> AbstractSQL (SQLStatement，通过list记录，使用sqlClause拼接)【可以区分条件、表】
2. 使用ScriptRunner执行脚本：构建：new ScriptRunner(Connection)；属性：异常终端、是否警告、自动提交、是否批量、是否去除window的换行符、是否支持转义、分隔符、分割符
3. SqlRunner：构建：new SqlRunner(Connection)；封装了JDBC，支持增删改查、执行、连接管理；SelectAll的逻辑：通过Connection获取PreparedStatement，调用setParameter为占位符赋值，其中setParameter是使用TypeHandleRegistry解析出参数中的TypeHandler，然后调用TypeHandler.setParameter；处理结果集：getResultSet：获取ResultSetMetaData对象（结果集元数据）、获取所有列的JDBC类型（获取对应的TypeHandler，注册到list中）、遍历ResultSet对象（调用TypeHandler的getResult方法，将JDBC类型转化为java类型，然后将记录转化为Map对象）
4. MetaObject：创建：SystemMetaObject.forObject(class)；通过setValue、getValue设置对象不同层级的属性值，通过hasSetter、hasGetter判断属性是否有对应的方法
5. MetaClass：反射工具类；MetaObject用于获取、设置对象的属性值，MetaClass判断是否有默认的构造方法；可以获取Getter/Setter；实现：MetaClass(Class<?> type, ReflectorFactory reflectorFactory)，通过反射工厂，为传入的type建立反射器（如果开启缓存，则首先判定是否已有该类的反射器），反射器包括：构造方法、get方法、set方法，属性（可读、可写；区分大小写）
6. ObjectFactory：对象工厂，创建Mapper映射结果对象的新实例，默认对象工厂仅实例化目标类（无参使用默认构造方法，有参即映射参数）；本身是一种扩展机制，在映射结果对象时，可以加入一些逻辑来处理参数（重写create方法）
7. ProxyFactory：代理工厂，创建动态代理对象（在创建Mapper映射结果对象后），实现懒加载，创建的事动态代理类的实例，原始对象的属性会被复制到代理对象中；实现：CglibProxyFactory（Cglib）和JavassistProxyFactory（javassist），在调用代理对象的Getter方法获取数据时会执行定义的拦截逻辑执行一次额外的查询；
# 核心组件
1. Configuration：主配置，启动时将Mapper、类型别名、TypeHandler等注册到Configuration组件中，转换成Configuration对象；包括：二级缓存、延迟加载、对象属性全加载、单一语句返回多结果集、列标签代替列名、使用自动生成的逐渐、自动映射列到java实体属性、自动映射目标未知列、默认的Executor类型、超时时间、默认的fetchSize、嵌套语句使用分页、自动开启驼峰映射、使用缓存机制防止循环引用和加速重复查询……；容器作用（针对TypeHandler、TypeAlias、Mapper、MapperSQL）：mapperRegistry、interceptorChain、typeHandlerRegistry、typeAliasRegistry、languageRegistry、mappedStatements、caches、resultMaps、parameterMaps、keyGenerators、loadedResources、sqlFragments、incompleteStatements、incompleteCacheRefs、incompleteResultMaps、incompleteMethods；采用工厂模式为Executor（Batch、Reuse、Simple、Caching）、StatementHandler、ResultSetHandler、ParameterHandler组件创建实例（实现插件拦截的逻辑）
2. MappedStatement：描述Mapper中的SQL配置信息（对标签、注解的封装）；属性：；实例与对象：cache（二级缓存）、sqlSource（sql标签解析结果）、resource（配置文件路径）、configuration（配置）、keyGenerator、hasNestedResultMaps、statementLog
3. SqlSession：面向用户的API，完成增删改查，是Executor组件的外观（设计模式中的外观模式）
4. Executor：SQL执行器，query和queryCursor用于执行查询操作，update用于执行插入、删除、修改；SimpleExecutor：完成基本的增删改查；ReuseExecutor对JDBC中的Statement对象做了缓存，相同操作可以复用（享元思想）；BatchExecutor：调用同一个Mapper的update、delete、insert操作，使用Statement的批量操作功能；CachingExecutor：当开启二级缓存，会使用CE对SE、RE、BE进行装饰，为查询操作增加二级缓存（装饰器模式）
5. StatementHandler：封装了对statement的操作（设置参数、与数据库交互），包括：创建S对象、设置占位符值、批处理执行、更新、查询（可带游标）、获取Mapper配置的SQL信息、获取ParameterHandler实例
6. ParameterHandler：在执行数据库交互前，为PreparedStatement和CallableStatement对象参数占位符设置值；主要包含set和get；setParameters：通过ParameterMapping描述参数映射，然后对所有参数映射信息进行遍历，根据参数名称、获取对应的参数值，调用对应的TypeHandler对象的setParameters方法为Statement对象的参数占位符设置值
7. ResultSetHandler：封装了对ResultSet的操作（当执行select时，将结果转换为java对象）；定义的三个方法：handleResultSets（处理后，返回结果实体list）、handleCursorResultSets（将ResultSet包装成Cursor，动态查询数据库，避免一次性加载全部数据）、handleOutputParameters（处理存储过程的调用结果）；DefaultResultHandler的handleResultSets方法逻辑：从stmt中获取RS，包装成RSW（ResultSetWrapper，方便获取表字段名、字段对应的TypeHandler信息）-> 获取ResultMap（解析Mapper接口、MapperSQL生成的，一条语句对应一个ResultMap）-> 调用handlerRS对RSW进行处理，结果放在multipleResults中
8. TypeHandler：处理java和jdbc之间的类型映射；涉及类型转换的场景：a.PreparedStatement为参数占位符设置值，调用接口中的set方法，进行类型转换（JAVA->JDBC） b.执行SQL获取ResultSet对象后，调用get方法进行类型转换（JDBC->JAVA）；BaseTypeHandler：对Null值、获取异常做了通用处理；通过TypeHandlerRegistry建立JDBC类型、java类型、TypeHandler之间的映射关系
# SqlSession的创建过程
1. 总体：Configuration的创建 -> SqlSessionFactory的创建 -> SqlSession实例化
2. XPath：XPathFactory.newInstance().newXPath().evaluate(“/users/*”,DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(Resources.getResourceAsStream("user.xml”),XPathConstants.NODESET)；
3. XmlParser：new XPathParser(Resources.getResourceAsStream("user.xml”)).evalNodes("/users/*”)、ConvertUtils.register(dateConverter, Date.class)、BeanUtils.setProperty(entity, "id", node.getLongAttribute("id”))、BeanUtils.setProperty(entity, childNode.getName(), childNode.getStringBody())
4. Configuration创建过程：描述MyBatis的配置、作为容器注册MyBatis其他组件（XXXXHandler、XXXStmt)、提供工厂方法创建组件（Executor、XXXXHandler）实例
5. 配置文件的标签：properties：配置属性信息，支持${}方式引用；settings：通过属性控制Mybatis运行时行为（日志实现、默认的Executor类型）；typeAlias：配置类型别名（减少类完全限定名的冗余）；plugins：注册用户自定义的插件；objectFactory：创建参数对象和结果集映射对象（自定义工厂）；objectWrapperFactory：创建ObjectWrapper对象（获取对象属性、方法名等反射信息）；reflectorFactory：创建描述Java类型反射信息的Reflector对象（获取Class对象的Setter/Getter方法、属性等信息）；environments：配置Mybatis数据连接相关的环境、事务管理器（配置多个，指定一个使用）；databaseIdProvider：根据不同的数据库厂商执行不同的SQL语句（通过dabtabaseId指定）；typeHandlers：注册用户自定义的类型处理器；mappers：配置Mapper信息
6. SqlSession的创建：new SqlSessionFactoryBuilder().build(Resources.getResourceAsReader("mybatis-config.xml")).openSession()；创建XMLConfigBuilder对象，调用其parse方法对主配置文件进行解析，生成Configuration对象，以该对象为参数，调用重载的build方法创建SqlSessionFactory（仅一个默认实现DefaultSqlSessionFactory），然后调用openSession中的openSessionFromDatasource创建SqlSession实例：根据<environment>、配置的事务管理器（JdbcTransaction【JDBC中的Connection对象】、ManagedTransaction【外部容器管理】）类型创建事务管理器工厂 -> 调用Configuration对象的newExecutor（根据配置文件中指定的Executor类型） -> 以Executor和Configuration作为参数，创建DefaultSqlSession对象（持有Executor对象的引用）
# SqlSession执行Mapper的过程
1. 总体：Mapper接口注册过程 -> 介绍MappedStatement对象的注册过程 -> Mapper方法调用过程 -> 介绍SqlSession执行Mapper过程
2. Mapper接口注册：SqlSession.getMapper -> 返回动态代理对象（MapperProxy<T>)；MapperProxy：JDK内置的动态代理，实现了InvocationHandler接口，invoke方法中为通用的拦截逻辑，调用java.lang.reflect.Proxy的newProxyInstance方法创建代理对象；以上过程封装在MapperProxyFactory创建Mapper动态代理对象过程中：MapperProxyFactory的newInstance是非静态的 -> 需要MPF的实例 -> MapperRegistry（Configuration的一个属性）注册Mapper和MapperProxyFactory对象的关系 -> MR中有addMapper方法：接受包名、类名作为参数，如果是类名直接判断是否存在（不存在创建新的MPF），如果是包名，遍历包下所有的类，通过Test.matches判断是否继承自（父类.isAssignableFrom(子类)）Object.class，然后逐一加入MR中
3. MappedStatement结构：在Configuration中，是Map对象，Key时SQL配置的ID（XML：命名空间+标签【select|update|delete|insert】；注解：接口的完全限定名【包括包名】+方法名称）
4. MS创建及注册：XMLConfigBuilder.parseConfiguration解析配置中的标签 -> mapperElement解析mappers（获取<mappers>的所有子标签、根据不同标签【resource、url、class、name】做不同的处理）：创建XMLMapperBuilder、调用其parse方法{configurationElement方法【buildStatementFromContext（为每一个XNode对象创建一个XMLStatementBuilder，调用parseStatementNode方法）】}
5. parseStatementNode方法：获取【select|update|delete|insert】标签的所有属性信息、将<include>替换为对应的<sql>、获取lang属性指定的languageDriver后创建SqlSource、获取KeyGenderator对象（不同实例代表不同的主键生成策略）、使用MapperBuilderAssistant（用于构建Mapper相关的对象，Cache、ParameterMap、ResultMap等）的addMappedStatement方法创建MS对象、调用Configuration的addMappedStatement将MS注册到Configuration中
6. MapperMethod对象创建：Mapper方法、Mapper接口、MapperSQL配置如何关联；调用SqlSession.getMapper获取动态代理对象 -> invoke（从Object继承的方法不做处理，Mapper接口定义的方法，调用cacheMapperMethod方法获取一个MapperMethod对象【缓存对象，没有就添加，享元思想】）；MapperMethod：Mapper方法的封装，包括SqlCommand对象（SQL语句类型、Mapper的Id等，由name和SqlCommandType构成，构造方法调用resolveMappedStatement方法或得MS）、MethodSignature对象（Mapper方法的参数名、参数注解）
7. resolveMappedStatement：将接口的完全限定名、方法名进行拼接，作为Mapper的Id从Configuration对象中查找对应的MS对象，找不到就判断该方法是不是从其父接口中继承的，如果是就以父接口作为参数递归调用
8. MethodSignature的构造方法：获取Mapper方法的返回值类型，具体是哪种类型，通过boolean标记；记录RowBounds参数位置（处理后续的分页查询），同时记录ResultHandler参数位置（处理从数据库中检索的每一行数据）；创建ParamNameResolver对象（解析Mapper方法中的参数名称、参数注解）
9. ParamNameResolver：对所有Mapper方法的所有参数信息进行遍历、判断参数中有木有Param注解（有就从中获取参数名称），如果没有就根据MyBatis主配置文件中的useActualParamName参数确定是否获取实际方法定义的参数名称，解析完成后将参数信息保存在一个不可修改的names属性（SortedMap<Integer, String>）中
10. Mapper方法执行：MapperProxy的invoke掉MapperMethod的execute方法：根据SqlCommand获取SQL语句的类型，然后根据SQL语句的类型调用SqlSession对象对应的方法【如：类型是INSERT，调用sqlSession.insert(command.getName, param)】
11. SqlSession执行Mapper过程：（以DefaultSqlSession的selectList为例）根据Mapper的Id从Configuration对象中获取对应的MappedStatement，以MS为参数调用Executor实例的query方法完成查询；BaseExecutor的query实现：从MS中获取BoundSql（动态SQL解析生成的SQL语句和参数映射信息的封装），创建CacheKey（缓存Key值），调用重载query方法：从一级缓存查询，如果没有则调用queryFromDatabase方法：调用doQuery查询，将结果进行缓存；SimpleExecutor的doQuery实现：调用Configuration的newStatementHandler创建StatementHandler（返回的实际是RoutingStatementHandler，根据配置Mapper的StatementType创建对应的SH），然后调用prepareStatement创建S，为其设置参数，然后调用SH的query进行查询
12. StatementHandler实现【Simple、Prepared、Callable】：（以Prepared为例）调用execute，然后调用ResultSetHandler的handleResultSets方法：从Statement中获取ResultSet对象，将RS包装成ResultSetWrapper（方便获取数据库字段及对应的TypeHandler）-> 获取ResultMap（从Mapper配置中） -> 调用handleResultSet对RSW进行处理，转化为Java实体对象，将生成的实体对象存放在multipleResults中 -> 调用collapseSingleResultList方法对multipleResults进行处理
# Mybatis缓存
1. 总体：合理使用减少IO，使用不当会带来数据一致性的问题；一级缓存基于SqlSession实现，二级缓存基于Mapper实现；装饰器模式
2. 一级缓存：不可关闭，原因：关键特性（通过association和collection建立级联映射、避免循环引用、加速重复嵌套查询），且结果集映射依赖于CacheKey；通过参数localCacheScope控制缓存级别（SESSION、STATEMENT）；级别为SESSION时，执行DML（更新）时，缓存才会被清除；级别为STATEMENT时，STMT执行完成就会清理缓存
3. 二级缓存：使用：主配置文件设置cacheEnabled为true，mapper配置中设置缓存策略（eviction）、缓存刷新频率（flushInterval）、缓存的容量（size）等属性，通过useCache属性指定Mapper执行时是否使用缓存，通过flushCache指定执行后是否刷新缓存
4. 缓存原理：基于JVM堆内存实现（数据存于java对象）；获取缓存ID、添加对象、获取对象、移除对象、清空缓存、获取读写锁（后续内核不使用，所有的锁需要缓存提供者内部实现）；BlockingCache（阻塞，保证一个时间只有一个线程可以访问）、FifoCache（先入先出，内部有一个长度限制的Key值链表【LinkedList】和一个缓存对象）、LoggingCache（增加日志输出，记录缓存的请求和命中次数，输出命中率）、LruCache（最近最少使用，使用LRU【least recently used】算法淘汰）、ScheduledCache（自动刷新缓存，当前时间与上次清空缓存的时间间隔大于指定的时间间隔，则清空，动作由get、put、remove触发）、SerializedCache（序列化，加入序列化，取出反序列化）、SoftCache（软引用，维护强引用和软引用队列，添加时放在软中，获取时如果发现已被回收，则删除对应的key，如果未被回收，则添加到强中，如果强满，则删除最早的对象引用）、SynchronizedCache（线程安全，使用synchronized关键字修饰缓存方法）、TransactionCache（事务，增加commit和rollback，只有调用commit才会添加到缓存，调用rollback，写入操作会回滚）、WeakCache（弱，和SoftCache仅引用类型不同）；使用CacheBuilder
5. 一级缓存原理：在BaseExecutor中实现，使用PerpetualCache实现，分为localCache（查询结果）、localOutputParameterCache（存储过程调用结果）；创建CacheKey（相关因素：Mapper的Id、查询结果的偏移量和条数、SQL语句和传递的参数、通过<environment>配置的环境信息的Id）；使用：在query中，根据key从localCache查找，没有就调用queryFromDatabase，将结果存入localCache，如果localCacheScope类型为STATEMENT（分布式环境下，如果类型不是STATEMENT，会导致数据一致性问题），查询完成后会清理缓存；update：在doUpdate前都会清空缓存
6. 二级缓存原理：Configuration的newExecutor根据defaultExecutorType创建对应的Executor实例 -> 如果cacheEnabled为true，使用CachingExecutor对Executor进行装饰 -> CachingExecutor维护一个TransactionCacheManager；CachingExecutor的query方法：调用createCacheKey创建缓存Key对象 -> 调用MappedStatement的getCache方法获取MS维护的二级缓存对象，如果获取不到，则查询数据库并添加到二级缓存内；Update：根据flushCache属性判断是否刷新缓存，然后调用update；
7. 二级缓存的创建：MappedStatement创建过程中创建二级缓存（XMLMapperBuilder解析Mapper配置时调用cacheElement解析<cache>，获取后，调用MapperBuilderAssistant的userNewCache创建二级缓存实例，使用currentCache保存二级缓存对象的引用，调用MBA的addMappedStatement创建MS时将当前命名空间对应的二级缓存对象引用添加到MS
8. 使用Redis缓存：使用mybatis-redis模块，在XML配置中增加缓存配置，在classpath下添加redis.properties
9. RedisCache：构造：获取RedisConfigurationBuilder（将redis.properties中的配置转化为RedisConfig），创建JedisPool与Redis服务器建立连接；使用Redis的Hash存放缓存数据，put前将java对象序列化（两种策略：JDK内置、第三方框架Kryo，在配置中配置）；JedisPool是RedisCache的静态属性，是所有RedisCache对象共享的
10. 其他：ehcache-cache、oscache-cache、memcached-cache
# 日志实现
1. Java日志体系及框架：Log4J（apache）、Log4J 2（apache）、Commons Logging（apache，原Jakarta）、SLF4J（Simple Logging Facade for Java）、Logback（属于SLF4J）、JUL（java util logging，1.4以后提供的实现）；如果使用JCL，在ClassPath下新增一个commons-logging.properties；SLF4J将接口与实现分开，可以做到日志系统无缝兼容；Logback框架完全实现了SLF4J-api的接口，且性能优于Log4j，因Log4j使用的比较普遍，因此推出了SLF4J-log4j12、SLF4J-jdk14，可以进行桥接；jcl-over-SLF4J将JCL调用桥接到SLF4J上，log4j-over-SLF4J把Log4j的调用桥接到SLF4J
2. Mybatis的Log接口：isDebugEnabled、isTraceEnabled、error、debug、trace、warn，支持7种策略：Apache Common Logging、Log4j 2、Log4j、JUL、No Logging、SLF4J、Stdout
3. LogFactory：指定日志框架（获取日志实现类的Constructor对象 -> 使用LogFactory的logConstructor记录该对象）；无论使用哪种日志实现，Mybatis可以按照顺序查找classpath下的日志框架相关jar包（static，顺序：SLF4J、JCL、Log4J 2、Log4J、JUL、No Logging）；配置文件中，通过指定logImpl指定使用哪种框架，名称参考Configuration中为日志实现类注册的别名，启动时调用setLogImpl方法，调用LogFactory
# 动态SQL原理
1. 标签：<where><if></if></where>；<choose|when|otherwise>；<foreach> ; <trim|set>（避免出现多余的连接词：，AND OR ）
2. SqlSource：描述SQL资源（注解、XML配置）；4个实现：StaticSqlSource（描述后三个实现解析后得到的静态SQL资源）、DynamicSS（XML配置，带有占位符）、RawSS（XML配置，在解析时就能确定）、ProviderSS（描述通过注解配置的SQL资源）
3. StaticSqlSource与BoundSql：封装Mapper解析后的SQL内容、Mapper参数映射信息；BoundSql（和Executor做交互）在SSS基础上封装了Mapper调用时传入的参数对象；Mapper有两个内置的参数_parameter（代表整个参数，包括<bind>标签绑定的参数信息，存放在BoundSql的additionalParameters中）、_databaseId（数据库类型）
4. LanguageDriver：将SQL配置转化为SqlSource对象；方法：createParameterHandler、createSqlSource（两个，针对XML和注解）；实现：XMLLanguageDriver（通过标签结合OGNL表达式语法实现动态SQL，注解中也可以使用标签的方式）、RawLanguageDriver（仅支持静态SQL）；脚本语言：3.2版本后支持可插拔脚本语言（velocity、freemaker）
5. SqlNode：apply方法：解析SQL节点，根据参数信息生成静态SQL内容，接收一个DynamicContext对象作为参数，封装了Mapper调用时传入的参数信息及Mybatis内置的_parameter和_databaseId；实现类：IfSqlNode、ChooseSqlNode、ForEachSqlNode、MixedSqlNode（一组SqlNode）、SetSqlNode、WhereSqlNode、TrimSqlNode、StaticTextSqlNode（静态文本）、TextSqlNode（静态文本中包含${}）、VarDeclSqlNode
6. MixedSqlNode的apply：通过list维护所有的SqlNode，然后遍历调用所有的对象的apply方法
7. StaticTextSqlNode的apply：将静态SQL文件追加到DynamicContext对象中
8. IfSqlNode的apply：维护ExpressionEvaluator的实例，根据当前参数对象解析OGNL表达式，维护<if>标签test属性指定的表达式内容和其对应的SqlNode对象，只有test属性为true时才会追加对应的SQL信息。
9. 动态Sql解析：XMLLanguageDriver的createSqlSource -> 创建XMLScriptBuilder，调用其parseScriptNode -> parseDynamicTags将SQL配置转换成SqlNode对象，判断是否是动态SQL（是否包含if、where、trim等或${}），是：创建DynamicSqlSource，否：创建RawSqlSource（SqlSource会存放在MappedStatement中）  -> 遍历SqlNode：如果是SQL文本，使用TextSqlNode描述该节点；如果是${}，设置XMLScriptBuilder的isDynamic属性为true；如果是if、where等，则使用对应的NodeHandler处理（XMLScriptBuilder构造方法中调用initNodeHandlerMap方法将所有NodeHandler的实例注册到Map中【享元思想】）->Executor操作数据库时，会调用MappedStatement的getBoundSql方法获取BoundSql对象（getBoundSql：根据参数对象创建DynamicContext，调用SqlNode的apply对动态SQL进行解析，调用SqlSourceBuilder对象的parse方法【创建ParameterMappingTokenHandler，处理SQL中的#{}参数占位符，接着创建一个GenericTokenParser，对SQL中的#{}参数占位符进行解析，获取#{}参数占位符中的内容，调用ParameterMappingTokenHandler的handleToken方法对参数占位符内容进行替换】对动态SQL解析后的结果进一步解析，返回StaticSqlSource对象）
10. 关于handleToken：将所有的#{}参数占位符替换成“?”，然后调用PreparedStatement的setXXX方法为参数占位符设置值，同时调用buildParameterMapping对占位符内容进行解析，将占位符替换成ParameterMapping对象，便于后续根据参数映射信息获取对应的TypeHandler为PreparedStatement设置值
11. \#{}和${}的区别：使用#{}参数占位符时，占位符先被替换成“?”，然后通过PreparedStatement对象的setXXX()方法为参数占位符设置值；${}会被直接替换成参数值；前者可以防止sql注入
# 插件原理及应用
1. 总述：本质是一个拦截器，在Configuration中维护一个InterceptorChain实例；过程：XMLConfigBuilder的pluginElement获取<plugin>的interceptor属性 -> 获取用户指定的拦截器属性转化为Properties -> java的反射机制实例化拦截器对象，将拦截器添加到Configuration中
2. 拦截的组件：Executor(update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)、ParameterHandler(getParameterObject, setParameters)、ResultSetHandler(handleResultSets, handleOutputParameters)、StatementHandler(prepare, parameterize, batch, update, query)
3. 拦截的原理：Configuration的三个作用（所有配置信息、中介者【简化交互、调用】、做为工厂为四个组件创建实例）；Configuration的newParameterHandler、newResultSetHandler、newStatementHandler、newExecutor，调用InterceptorChain的pluginAll方法，返回PH、RSH、SH、E的代理对象
